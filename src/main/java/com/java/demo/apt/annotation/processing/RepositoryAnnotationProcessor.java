package com.java.demo.apt.annotation.processing;

import javax.annotation.processing.*;
import javax.lang.model.SourceVersion;
import javax.lang.model.element.AnnotationMirror;
import javax.lang.model.element.Element;
import javax.lang.model.element.ElementKind;
import javax.lang.model.element.TypeElement;
import javax.lang.model.type.DeclaredType;
import javax.lang.model.type.TypeMirror;
import javax.lang.model.util.Types;
import javax.tools.FileObject;
import javax.tools.StandardLocation;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.Writer;
import java.lang.reflect.Modifier;
import java.util.*;

@SupportedAnnotationTypes(RepositoryAnnotationProcessor.REPOSITORY_ANNOTATION_CLASS_NAME)
@SupportedSourceVersion(SourceVersion.RELEASE_8)
public class RepositoryAnnotationProcessor extends AbstractProcessor {

    public static final String REPOSITORY_ANNOTATION_CLASS_NAME = "com.java.demo.apt.annotation.exmple.Repository";

    private static final String CRUD_REPOSITORY_INTERFACE_CLASS_NAME = "com.java.demo.apt.annotation.exmple.CrudRepository";

    private Map<String,String> crudRepositoryParameterizedTypeMapping = new HashMap<>();

    @Override
    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {

        roundEnv.getRootElements()
                .stream()
                .filter(this::isRepositoryAnnotationPresent)
                .forEach(this::processRepositoryAnnotatedElement);

        if (roundEnv.processingOver()){
            try {
                generateCrudRepositoryParameterizedTypeMetadata();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        return false;
    }

    private void generateCrudRepositoryParameterizedTypeMetadata() throws IOException {
        Filer filer = processingEnv.getFiler();
        String resources = "META-INF/javax.annotation.processing.Processor";
        FileObject fileObject = filer.createResource(StandardLocation.CLASS_OUTPUT,"",resources);

        try(Writer writer = fileObject.openWriter()){
            Properties properties = new Properties();
            properties.putAll(crudRepositoryParameterizedTypeMapping);
            properties.store(writer,"Generated by RepositoryAnnotationProcessor");
        }
    }

    private void processRepositoryAnnotatedElement(Element element) {

        if (!isConcreteClass(element) || !isCrudRepositoryType(element)){
            return;
        }

        TypeMirror crudRepositoryGenericInterfaceType = getGenericTypeInterfaces(element,CRUD_REPOSITORY_INTERFACE_CLASS_NAME);

        DeclaredType declaredType = DeclaredType.class.cast(crudRepositoryGenericInterfaceType);

        List<? extends TypeMirror> parametrizedTypes = declaredType.getTypeArguments();

        TypeMirror firstType = parametrizedTypes.get(0);

        crudRepositoryParameterizedTypeMapping.put(crudRepositoryGenericInterfaceType.toString(),firstType.toString());

    }

    private boolean isCrudRepositoryType(Element element) {
        return getGenericTypeInterfaces(element,CRUD_REPOSITORY_INTERFACE_CLASS_NAME)!=null;
    }

    private TypeMirror getGenericTypeInterfaces(Element element, String crudRepositoryInterfaceClassName) {
        ElementKind kind = element.getKind();
        if (kind.isClass() && element instanceof TypeElement){
            TypeElement typeElement = (TypeElement)element;
            typeElement.getInterfaces().stream()
                    .filter(interfaceType-> typeEquals(interfaceType,crudRepositoryInterfaceClassName))
                    .findFirst()
                    .orElse(null);
        }
        return null;
    }

    private boolean typeEquals(TypeMirror typeMirror, String crudRepositoryInterfaceClassName) {
        Types types = processingEnv.getTypeUtils();
        TypeMirror erasedType = types.erasure(typeMirror);
        return Objects.equals(crudRepositoryInterfaceClassName,erasedType.toString());
    }

    private boolean isConcreteClass(Element element) {
        return !element.getModifiers().contains(Modifier.ABSTRACT);
    }

    private boolean isRepositoryAnnotationPresent(Element element) {
        return isAnnotationPresent(element,REPOSITORY_ANNOTATION_CLASS_NAME);
    }

    private boolean isAnnotationPresent(Element element, String repositoryAnnotationClassName) {
        return element.getAnnotationMirrors()
                .stream()
                .filter(annotation-> Objects.equals(repositoryAnnotationClassName,((AnnotationMirror) annotation).getAnnotationType().toString()))
                .count()>0;
    }
}
